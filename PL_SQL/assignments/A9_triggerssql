--SET SERVEROUTPUT ON;
--1. Write a PL/SQL trigger named "update_salary_trigger" that automatically updates the "new_salary" column in the "employee"
--table with a 10% increase whenever a new record is inserted into the "salary_change" table.
--
CREATE TABLE SALARY_CHANGE
  (
    EMPLOYEE_ID NUMBER,
    change_date DATE DEFAULT SYSDATE
  );
BEGIN
  INSERT INTO salary_change
    (employee_id
    ) VALUES
    (101
    );
END;
/
CREATE OR REPLACE TRIGGER update_salary_trigger AFTER
  INSERT ON salary_change FOR EACH ROW BEGIN
  UPDATE EMPLOYEES
  SET salary        = (salary * 1.1)
  WHERE employee_id = :NEW.employee_id;
END;
/
--2. Create a trigger named "check_inventory_trigger" that prevents the insertion of a new order into the "orders" table
--if the ordered quantity exceeds the available quantity in the "products" table.
CREATE TABLE PRODUCTS
  (
    product_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
    PRODUCT_NAME VARCHAR2(20),
    QUANTITY     NUMBER DEFAULT 0,
    CONSTRAINT pk_products PRIMARY KEY (product_id)
  );
CREATE TABLE ORDERS
  (
    PRODUCT_ID     NUMBER,
    ORDER_QUANTITY NUMBER,
    ORDER_DATE     DATE DEFAULT SYSDATE,
    CONSTRAINT fk_orders_products FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS(PRODUCT_ID)
  );
CREATE OR REPLACE TRIGGER check_inventory_trigger BEFORE
  INSERT ON orders FOR EACH ROW DECLARE v_quantity_available NUMBER := 0;
  BEGIN
    SELECT QUANTITY
    INTO v_quantity_available
    FROM PRODUCTS
    WHERE PRODUCT_ID       = :NEW.PRODUCT_ID;
    IF :NEW.ORDER_QUANTITY > v_quantity_available THEN
      raise_application_error(-20001, 'Ordered quantity exceeds available quantity. Please try with a lesser quantity.');
    END IF;
  END;
  /
  BEGIN
    --INSERT INTO PRODUCTS(PRODUCT_NAME,QUANTITY) VALUES('pc',50);
    INSERT
    INTO ORDERS
      (
        PRODUCT_ID,
        ORDER_QUANTITY
      )
      VALUES
      (
        1,51
      );
  EXCEPTION
  WHEN OTHERS THEN
    dbms_output.put_line(SQLCODE|| sqlerrm);
  END;
  /
  --3. Develop a trigger called "audit_inserts_trigger" that logs the details of every INSERT statement executed on the "customer" table
  -- into an "audit_log" table.
  CREATE TABLE customer
    (
      customer_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
      customer_name VARCHAR2(100),
      created_date  DATE DEFAULT SYSDATE,
      CONSTRAINT pk_customer PRIMARY KEY (customer_id)
    );
  CREATE TABLE audit_log
    (
      log_id        NUMBER GENERATED BY DEFAULT AS IDENTITY,
      audit_date    DATE,
      operation     VARCHAR2(50),
      customer_id   NUMBER,
      customer_name VARCHAR2(100),
      CONSTRAINT pk_audit_log PRIMARY KEY (log_id),
      CONSTRAINT fk_audit_log_customer FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
    );
CREATE OR REPLACE TRIGGER audit_inserts_trigger AFTER
  INSERT ON customer FOR EACH ROW BEGIN
  INSERT
  INTO audit_log
    (
      audit_date,
      operation,
      customer_id,
      customer_name
    )
    VALUES
    (
      SYSDATE,
      'INSERT',
      :NEW.customer_id,
      :NEW.customer_name
    );
END;
/
BEGIN
  INSERT INTO CUSTOMER
    (CUSTOMER_NAME
    ) VALUES
    ('Nitin'
    );
END;
/
SELECT * FROM CUSTOMER;
SELECT * FROM audit_log;
--4. Write a trigger named "discount_trigger" that automatically updates the "discount" column in the "orders" table.
--   If the total order ORDER_QUANTITY is greater than 20, set the discount to 15%; otherwise, set it to 5%.
ALTER TABLE orders ADD discount NUMBER DEFAULT 0;
CREATE OR REPLACE TRIGGER discount_trigger BEFORE
  INSERT OR
  UPDATE ON orders FOR EACH ROW BEGIN IF :NEW.ORDER_QUANTITY > 20 THEN :NEW.discount := 0.15;
ELSE
  :NEW.discount := 0.05;
END IF;
END;
/
BEGIN
  INSERT INTO orders
    (PRODUCT_ID,ORDER_QUANTITY
    ) VALUES
    (1,21
    );
END;
/
--5. Create a trigger named "update_total_trigger" that automatically updates the "total_amount" column in the "orders" table
--   whenever a new order item is inserted or updated. Handle the "mutating table" error appropriately.
--6. Design a trigger named "update_manager_salary" that automatically updates the "salary" of the manager
--   whenever an employee's salary in the "employee" table is updated.
CREATE OR REPLACE TRIGGER UPDATE_MANAGER_SALARY BEFORE
  UPDATE ON EMPLOYEES FOR EACH ROW DECLARE v_mng_id employees.MANAGER_ID%type ;
  BEGIN
    SELECT MANAGER_ID
    INTO V_MNG_ID
    FROM EMPLOYEES
    WHERE employee_id=:old.employee_id;
    IF v_mng_id     IS NOT NULL THEN
      UPDATE EMPLOYEES SET SALARY=:NEW.SALARY*1.5 WHERE EMPLOYEE_ID=V_MNG_ID;
    END IF;
  END;
  /
  BEGIN
    UPDATE EMPLOYEES SET SALARY=10000 WHERE employee_id=101;
  END;
  /
  --
  --7. Write a trigger named "check_credit_limit_trigger" that prevents inserting a new order into the "orders" table
  --   if the customer's total order amount would exceed their predefined credit limit.
  --8. Create a trigger named "employee_history_trigger" that captures the previous values of the "salary" and "job_title"
  --   columns in the "employee_history" table whenever an update occurs in the "employee" table.
  CREATE TABLE EMPLOYEE_HISTORY
    (
      history_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      EMPLOYEE_ID        NUMBER,
      PREVIOUS_SALARY    NUMBER,
      PREVIOUS_JOB_TITLE VARCHAR2(100),
      change_date        DATE DEFAULT SYSDATE,
      CONSTRAINT FK_EMPLOYEE_ID FOREIGN KEY (EMPLOYEE_ID) REFERENCES EMPLOYEES(EMPLOYEE_ID)
    );
CREATE OR REPLACE TRIGGER EMPLOYEE_HISTORY_TRIGGER BEFORE
  UPDATE ON EMPLOYEES FOR EACH ROW DECLARE V_EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
  V_SAL EMPLOYEES.SALARY%TYPE;
  V_JOB_TITLE JOBS.JOB_TITLE%TYPE;
  BEGIN
    V_EMP_ID:= :OLD.EMPLOYEE_ID;
    v_sal   :=:old.salary;
    SELECT JOB_TITLE INTO V_JOB_TITLE FROM JOBS WHERE JOB_ID=:OLD.JOB_ID;
    INSERT
    INTO EMPLOYEE_HISTORY
      (
        EMPLOYEE_ID,
        PREVIOUS_SALARY,
        PREVIOUS_JOB_TITLE
      )
      VALUES
      (
        V_EMP_ID,
        V_SAL,
        V_JOB_TITLE
      );
  END ;
  /
  BEGIN
    UPDATE EMPLOYEES SET SALARY=SALARY*1.1 WHERE EMPLOYEE_ID=101;
  END;
  /
  --UPDATE EMPLOYEES
  --SET job_id= 6
  --WHERE EMPOYEE_ID=101;
  --UPDATE EMPLOYEES
  --SET SALARY=SALARY*1.1, job_id=4
  --WHERE EMPOYEE_ID=101;
  --END;
  --/
  --9. Develop a trigger named "update_product_stock_trigger" that automatically updates the "stock_quantity" in the "products" table
  --   when a new order is inserted into the "order_details" table.
  --
  --10. Write a script that deactivates the "discount_trigger" from exercise 4 and then reactivates it after a specified period.